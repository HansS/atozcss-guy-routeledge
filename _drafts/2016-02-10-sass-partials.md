---
layout: blog_page
title: "AtoZ Sass: Partials"
category: blog
excerpt: >
  
summary: |
  
---

This is part 3 of a 4-part introductory series to Sass in preparation
for the video series [AtoZ Sass](http://www.atozsass.com).

* Part 1: [What is Sass](/blog/what-is-sass/)
* Part 2: [Installing Sass](/blog/installing-sass/)
* Part 3: Organising Sass with Partials
* Part 4: Variables, Mixins and Nested Selectors

Having [installed Sass and setup our environment](/blog/installing-sass)
in the previous post, we're now ready to take a look at how Sass can
make us better developers and help organise our code.

In this post we'll learn:

* the number one problem with vanilla CSS projects
* all about Sass partials
* my Sass folder structure 

## CSS Maintainability

In my opinion, the most difficult thing about CSS on a real-world
project is maintaining it. This is exacerbated when dealing with a team
of developers rather than a single person.

The CSS file for a (medium-sized) project I was working on recently was
over 9000 lines long. This file was actually generated by Sass but it
will serve to prove the point.

Having such a huge, single CSS file leads to two big problems.

Firstly, if anyone needs to make a change, they have to search through
a huge file to find an appropriate place. The find and replace tool in
a text editor will help a lot but there's a good chance that someone
will be lazy and just throw some css at the end of the file.

The second issue is a much more serious one. Let's say there's two
people working on the project and they both need to change some CSS. 

They both need to work in the same file. What happens when they both
move a load of stuff around or both change the same line of code?

If the project is version controlled, any conflicts will be caught but
they will need to be resolved (sometimes manually) which is not *always*
a straightforward process and can be fraught with human error. 

If the project isn't version controlled, then things can very quickly
unravel and the likelihood of code conflicting or being overwritten is
much higher.

Personally, I wouldn't ever want to work on a project that didn't use
a pre-processor or version control ever again!

Sass is a huge help regarding this side of maintainability as we can
split our styles up into many small files and combine them all together
at compile time.


## Partials

In the previous part of this series, we used the command line `sass`
command to compile a file named `style.scss` into `style.css`. But
with Sass we can create multiple *partial* files and combine them into
one compiled stylesheet using the Sass `@import` statement.

Partial files are only special in that their file name starts with an
`_` underscore character.

From the previous post, we ended up with a sample project with the
following structure:

{% highlight bash %}
|- css
   |-- style.css
|- scss
   |- style.scss
{% endhighlight %}

To illustrate how Sass partials work, let's add a file called
`_base.scss` in the `scss` folder and open it up in a text editor. If
you're following along, do make sure to run your compiler and watch the
project for changes.

In every project I tend to have a `_base.scss` partial where I put all
my "sensible default" styles; things like default heading sizes, link
colours, consistent margins and padding for form elements and list
items, that kind of thing.

In `_base.scss` file, add a few lines of CSS. Remember that any valid
CSS is also valid Sass when using the SCSS syntax.

{% highlight css %}
body {
	font-size:100%;
	font-family: Helvetica, Arial, sans-serif;
	background:#f1f1f1;
}
h1, h2, h3, h4, h5, h6, p, li, input {
	margin-bottom:1rem;
}
a {
	color:#cc3f85;
}
a:hover {
	color:#b23430;
}
{% endhighlight %}

When saving this file, Sass won't detect any changes.  When checking the
contents of the compiled `style.css` file, there won't be any sign of
the code that's just been added.

To have Sass compile these styles, they need to be imported into
`style.scss`.  We can do that with the `@import` statement followed by
the name of the partial *without* the underscore and file extension.

Add the following to `style.scss`:

{% highlight scss %}
	@import 'base';
{% endhighlight %}

If we save now, Sass will pick up the change and the styles from the
`_base.scss` file will be visible in the compiled CSS.

This method of splitting up related styles into their own file goes
a long way to solve the maintainability problems mentioned earlier.


## Sass architecture

CSS architecture is a hotly debated topic and much of it also comes down
to personal preference. Over the years I've developed a system that
works for me and I'll explain it here for you.

I tend to break my `scss` folder into two sub-folders: "includes"
and "global". 

`includes` is a folder of Sass partials that generate little
or no CSS rules when compiled. To understand what that actually means,
you'll have to tune in for future episodes of AtoZ Sass as it's a little
complex to explain as part of an intro to Sass.

The `global` is further divided into four sub-folders.

* Layout
* Components
* Pages
* Vendor

The `layout` folder contains styles for the big-picture layout elements,
often things that are present on multiple (or every) page of a site:
the header, footer, sidebar, etc.

The `components` folder contains a series of partials, each with
a single concern. Typically I'll have a partial just for button styles,
one for user avatars, one for modal dialogs etc. Ever component on the
site is split out into its own file and as far as possible, components
should be able to be used anywhere in the site without causing weird
side effects.

The `pages` folder is for page specific styles. These are typically
quite short files as the vast majority of layout and UI is handled by
the base styles and components. 

Finally, the `vendor` folder is for 3rd-party library code that might be
for frameworks, plugins or grid systems.

Every project is different but I've found this folder structure has
served me well across a range of projects from mobile prototypes to
custom Wordpress themes to Ruby on Rails applications.

In the next post we'll combine this knowledge of partials with three
more Sass features and start working towards some more significant examples.

There's one more intro post and just two more weeks to go until [AtoZ
Sass](http://www.atozsass.com) launches. Help me spread the word with
a tweet:

> "AtoZ Sass is launching soon! Learn #Sass and #CSS in bite-sized videos. So Excited!"
>
> [Click to tweet this](http://twitter.com/?status=AtoZ%20Sass%20is%20launching%20soon!%20Learn%20%23Sass%20and%20%23CSS%20in%20bite-sized%20videos%20So%20excited!%20http://www.atozsass.com)

## Other Posts in this Series

* Part 1: [What is Sass](/what-is-sass)
* Part 2: [Installing Sass](/installing-sass)
* Part 3: Organising Sass with Partials
* Part 4: Variables, Mixins and Nested Selectors
